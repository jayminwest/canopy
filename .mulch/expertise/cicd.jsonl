{"type":"pattern","name":"bun-cicd-pattern","description":"CI/CD infrastructure for Bun/TypeScript projects: ci.yml (lint+typecheck+test on push/PR to main via oven-sh/setup-bun@v2), auto-tag.yml (workflow_run trigger after CI success, verifies package.json and src/index.ts versions match before tagging, idempotent tag check). version-bump.ts atomically updates both version locations with rollback on failure. /release command always defaults to patch bump.","classification":"tactical","recorded_at":"2026-02-23T18:46:34.848Z","outcomes":[{"status":"success","agent":"cicd-builder"}],"id":"mx-9b7453"}
{"type":"pattern","name":"bun-ts-extensions-tsconfig","description":"Bun/TS projects need allowImportingTsExtensions:true in tsconfig.json when using .ts import extensions with bundler moduleResolution. Without it, tsc errors with TS5097.","classification":"tactical","recorded_at":"2026-02-23T22:32:01.048Z","outcomes":[{"status":"success","agent":"canopy-builder-2"}],"id":"mx-85ed38"}
{"type":"pattern","name":"jsonl-dedup-pattern","description":"For JSONL stores with multiple record types, use separate dedup functions: dedupById (version-based, last highest version wins) for versioned records like prompts, and dedupByIdLast (insertion order, last wins) for unversioned records like schemas.","classification":"tactical","recorded_at":"2026-02-23T22:32:04.761Z","outcomes":[{"status":"success","agent":"canopy-builder-2"}],"id":"mx-03bd0d"}
{"type":"pattern","name":"greenfield-build-orchestration","description":"Full greenfield build: single lead spawning parallel builders. Builder-2 completed entire canopy (41 files, 3942 LOC, 62 tests) in 28 min. Lesson: for projects with tight internal deps, one comprehensive builder is faster than parallel partial builders. Always merge immediately on merge_ready — previous session lost work by not merging before worktree cleanup.","classification":"tactical","recorded_at":"2026-02-23T22:35:09.138Z","id":"mx-05ac19"}
{"type":"convention","content":"biome.json in Bun/TS projects must ignore tool directories (.beads, .claude, .seeds, .mulch, .overstory) to prevent lint failures on tool-generated config files like metadata.json and settings.json","classification":"tactical","recorded_at":"2026-02-23T22:44:10.630Z","outcomes":[{"status":"success","agent":"cn-build-core"}],"id":"mx-2fbf14"}
{"type":"pattern","name":"canopy-cli-pattern","description":"Canopy CLI: JSONL store with advisory file locking and atomic writes (tmp+rename). 17 commands in src/commands/, tests use process.chdir() for real I/O isolation in tmpdir. biome.json must exclude .beads and .claude dirs. Bun test shares process — process.chdir() in tests can affect tool cwd; always restore in afterEach.","classification":"tactical","recorded_at":"2026-02-23T22:45:16.632Z","outcomes":[{"status":"success","agent":"canopy-builder"}],"id":"mx-3016c1"}
{"type":"failure","description":"process.exit(1) inside lock-guarded try/finally blocks skips the finally in Bun, leaving stale .lock files that block all subsequent write commands.","resolution":"Throw a sentinel ExitError class instead of process.exit(1) inside lock-guarded blocks. Catch ExitError at the top-level runner in index.ts and call process.exit(exitCode) there, after finally has released the lock.","classification":"tactical","recorded_at":"2026-02-23T23:39:59.959Z","id":"mx-4a480a"}
{"type":"pattern","name":"repeatable-flag-accumulation","description":"Canopy CLI arg parsing: repeatable flags (--section, --required, --tag) must push/accumulate into arrays, not reassign. Use key=value shorthand for --section (split on first '=') with fallback to --section name --body value two-flag form.","classification":"tactical","recorded_at":"2026-02-23T23:40:09.415Z","id":"mx-91ddd8"}
{"type":"pattern","name":"pinned-version-full-history","description":"When resolvePrompt needs to find a specific pinned version, pass allRecords (full JSONL history) not dedupById (latest-only). dedupById strips old versions, so pinned version lookups fail with 'not found'.","classification":"tactical","recorded_at":"2026-02-23T23:40:10.432Z","id":"mx-766f7f"}
{"type":"convention","content":"ExitError pattern for Canopy CLI: commands that fail inside lock-guarded blocks throw ExitError (src/types.ts) instead of process.exit(1). The top-level catch in index.ts handles ExitError by calling process.exit(exitCode) after the lock is safely released.","classification":"tactical","recorded_at":"2026-02-23T23:40:11.482Z","id":"mx-301cd1"}
{"type":"convention","content":"GitHub Actions: use actions/checkout@v6 (not v4) for all workflows. Dependabot with weekly schedule for both npm and github-actions ecosystems keeps these current.","classification":"tactical","recorded_at":"2026-02-23T23:40:31.232Z","id":"mx-1eaa60"}
{"type":"pattern","name":"open-source-governance-files","description":"Open source governance file set for Bun/TS projects: LICENSE, CODEOWNERS, CONTRIBUTING.md, SECURITY.md, .github/pull_request_template.md, .github/ISSUE_TEMPLATE/{bug_report.yml,feature_request.yml,config.yml}, .github/dependabot.yml, .github/FUNDING.yml. Adapt from sister projects but replace runtime-specific references (Node→Bun, vitest→bun:test, .js→.ts imports, npm→bun commands).","classification":"tactical","recorded_at":"2026-02-23T23:40:41.965Z","id":"mx-90582f"}
{"type":"convention","content":"package.json metadata for open source: always include description, keywords, author, license, repository (with .git URL), and engines fields. For Bun projects use engines.bun (not engines.node). Biome enforces compact JSON arrays on single lines — don't expand keywords array across multiple lines.","classification":"tactical","recorded_at":"2026-02-23T23:40:42.161Z","id":"mx-e7983f"}
{"type":"pattern","name":"exit-error-everywhere","description":"ExitError pattern: all Canopy CLI commands must throw ExitError(1) instead of process.exit(1) to prevent double error printing. The top-level catch in index.ts handles ExitError silently (just exits). process.exit(1) in async functions causes the run().catch() handler to also fire, printing the error a second time.","classification":"tactical","recorded_at":"2026-02-24T00:05:20.576Z","evidence":{"commit":"aea02bd"},"id":"mx-f89c48"}
{"type":"pattern","name":"commander-register-pattern","description":"Commander register pattern for Canopy CLI: each command exports register(program: Command) that creates a subcommand. The action reconstructs args and calls default(args, json) for test compatibility. Index.ts imports and calls each register(). Pass-through commands use process.argv.slice(3) to forward raw args to legacy default() functions.","classification":"tactical","recorded_at":"2026-02-24T04:07:21.240Z","outcomes":[{"status":"success","agent":"cmd-core-builder"}],"id":"mx-65c360"}
{"type":"pattern","name":"commander-register-pattern","description":"Commander register pattern for Canopy CLI: each command exports register(program: Command) that wires up Commander subcommands/options/arguments and calls the existing default(args, json) function by reconstructing the args array. Preserves test compatibility while enabling Commander routing. Repeatable flags use collector: .option('--tag <tag>', 'desc', (v, a) => a.concat([v]), []). Nested subcommands: program.command('schema').command('create'). Global --json accessed via program.opts().json in action callbacks.","classification":"tactical","recorded_at":"2026-02-24T04:07:52.588Z","outcomes":[{"status":"success","agent":"cmd-complex-builder"}],"id":"mx-65c360"}
{"type":"convention","content":"When running biome lint from a worktree inside .overstory/, the 'bun run lint' script fails because the worktree path is ignored by biome's \\!**/.overstory pattern. Use explicit --config-path and absolute src/ path: bunx biome check --config-path=<worktree>/biome.json <worktree>/src/. Or use bunx biome check --write for auto-fix.","classification":"tactical","recorded_at":"2026-02-24T04:07:57.366Z","outcomes":[{"status":"success","agent":"cmd-complex-builder"}],"id":"mx-f186a6"}
{"type":"convention","content":"Commander action callbacks with opts params require explicit Record<string, unknown> type annotation. Without it, opts is inferred as any (from Commander's ...args: any[] action signature), which works but loses type safety. Adding Record<string, unknown> enables property access with proper unknown typing and makes explicit type casts (opts.name as string) clearly intentional.","classification":"tactical","recorded_at":"2026-02-24T04:23:23.202Z","outcomes":[{"status":"success","agent":"typecheck-builder"}],"id":"mx-1d7949"}
